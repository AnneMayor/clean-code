# 11. 시스템

- 도시를 세운다면?
    - 도시가 돌아가는 이유는 적절한 추상화와 모듈화 때문이다.
    - 소프트웨어 팀도 도시처럼 구성한다.
    - 깨끗한 코드를 구현하면 낮은 추상화 수준에서 관심사를 분리하기 쉬워진다.

## 시스템 제작과 시스템 사용을 분리하라

- 제작 construnction / 사용 use 둘은 아주 다르다 분리해야한다.
- `시작단계`는 모든 애플리케이션이 풀어야할 `관심사`(concern) 이다.
    - 분리하지 않으면, 준비 과정 코드를 주먹구구식으로 구현할 뿐만 아니라 런타임 로직과 마구 뒤섞는다.

### Main 분리

- 시스템 생성과 사용을 분리하는 방법
    - 생성관련된 코드는 main, main이 호출하는 모듈로 옮긴다.
    - 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정
- main함수에서는 시스템에 필요한 객체 생성 후 애플리케이션에 넘김
- 애플리케이션은 그저 객체를 사용하기만 함

### 팩토리

- 객체가 생성되는 시점을 애플리케이션이 결정할 필요도 생긴다.

### 의존성 주입

- 제어 역전에서는 한 객체가 맡은 보조 책임을 새로운 객체에게 전적으로 떠넘긴다.
- 새로운 객체는 넘겨받은 책임만 맡으므로 `단일 책임원칙` 을 지키게 된다.
- 초기 설정은 시스템 전체에서 필요하므로 대개 ‘책임질' 메커니즘으로 ‘main’루틴이나 특수 `컨테이너` 를 사용한다.
- 호출하는 객체는 실제로 반환되는 객체의 유형을 제어하지 않는다. 대신 호출하는 객체는 의존성을 능동적으로 해결한다.
- new 라는 생성자 명령어를 통해서 객체를 생성하고 호출하는 방식 → **프레임워크**에서도 하나의 객체를 생성하는 모듈을 두고 걔가 모든 객체를 생성, 소멸을 관리

### 확장

- ‘처음부터 올바르게' 시스템을 만들 수 있다는 믿음은 미신이다.
- TDD, 리팩터링, 깨끗한 코드는 코드 수준에서 시스템을 조정하고 확장하기 쉽게 만든다.
- 소프트웨어 시스템은 물리적인 시스템과 다르다. 관심사를 적절히 분리해 관리한다면 소프트웨어 아키텍처는 점진적으로 발전할 수 있다.

### 횡단(cross-cutting) 관심사

- 원론적으로는 모듈화되고 캡슐화된 방식으로 영속성 방식을 구상할 수 있다. 현실적으로는 영속성 방식을 구현한 코드가 온갖 객체로 흩어진다. 여기서 `횡단 관심사` 라는 용어가 나온다.
- AOP 에서 `관점` 이라는 모듈 구성 개념은 ‘특정 **관심사**를 지원하려면 시스템에서 특정 지점들이 동작하는 방식을 일관성 있게 바꿔야 한다’ 라고 명시한다.
- 자바에서 사용하는 관점 혹은 관점과 유사한 메커니즘
    - **자바 프록시**
        - 단순한 상황에 적합
        - 개별 객체나 클래스에서 메서드 호출을 감싸는 경우
        - 프록시를 하용하면 깨끗한 코드를 작성하기 어렵다!
        - 시스템 단위로 실행 ‘지점'을 명시하는 메커니즘도 제공하지 않는다.
    - **순수 자바 AOP 프레임워크**
        - app.xml 설정파일과 시스템 내 최상위 객체 요청은 사실상 스프링 관련 자바 코드가 거의 `독립적` 이다.
    - AspectJ관점
        - 언어 차원에서 관점을 모듈화 구성으로 지원하는 자바언어 확장이다.

## 테스트 주도 시스템 아키텍처 구축

- BDUF(Big Design Up Front)는 추구할 필요가 없다. 실제로 해로울 수 있다.
- 처음에 쏟아 부은 노력을 버리지 않으려는 심리적 저항으로 인해, 변경을 쉽사리 수용하지 못할 수 있다.
- ‘아주 단순하면서도' 멋지게 분리된 아키텍처로 소프트웨어 프로젝트를 진행해 결과물을 재빨리 출시 한 후 기반구조를 추가하며 조금씩 확장해 나가는 것도 괜찮다.
- ‘아무 방향 없이' 뛰어들어도 좋다는 소리는 아니다.

## 의사결정을 최적화하라

- 모듈을 나누고 관심사를 분리하면 지엽적인 관리와 결정이 가능해진다.
- 성급한 결정은 불충분한 지식으로 내린 결정이다.

## 명백한 가치가 있을 때 표준을 현명하게 사용하라

## 시스템은 도메인 특화 언어가 필요하다

- DSL(Domain Specific Language) : 간단한 스크립트 언어나 표준 언어로 구현한 API
- 좋은 DSL은 의사소통의 간극을 줄여준다.

## 결론

시스템 설계하든 모듈을 설계하든, 실제로 **돌아가는 가장 단순한 수단을** 사용해야 한다는 사실을 명심하자.
